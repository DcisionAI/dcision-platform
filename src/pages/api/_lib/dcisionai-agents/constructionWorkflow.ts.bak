// Construction Workflow Orchestrator
// Coordinates all DcisionAI agents using the real Agno backend

import { agnoDataAgent, EnrichedData } from './dataAgent/agnoDataAgent';
import { agnoIntentAgent, IntentResult } from './intentAgent/agnoIntentAgent';
import { agnoModelBuilderAgent } from './modelBuilderAgent/agnoModelBuilderAgent';
import { MCPConfig } from '../mcp/MCPTypes';
import { ConstructionMCPSolver } from '../mcp-solver/ConstructionMCPSolver';
import { agnoExplainAgent, Explanation } from './explainAgent/agnoExplainAgent';
import { agnoClient, AgnoChatRequest } from '../lib/agno-client';

// Import RAG functionality
import { queryVectors } from '../utils/RAG/pinecone';
import { embedChunks } from '../lib/RAG/embedding';
import { getLLMAnswer } from '../lib/RAG/llm';

export interface ConstructionWorkflowResult {
  sessionId: string;
  enrichedData?: EnrichedData;
  intent: IntentResult;
  mcpConfig?: MCPConfig;
  optimizationProblem?: ConstructionOptimizationProblem;
  optimizationResult?: ConstructionOptimizationResult;
  explanation: Explanation;
  // RAG-specific fields
  ragResult?: {
    answer: string;
    sources: any[];
    query: string;
  };
  metadata: {
    startTime: string;
    endTime: string;
    duration: number;
    modelProvider: string;
    modelName: string;
    agentIds: string[];
    solverUsed?: string;
    highsAvailable?: boolean;
    executionPath: 'rag' | 'optimization' | 'hybrid';
  };
}

export interface WorkflowOptions {
  modelProvider: 'anthropic' | 'openai';
  modelName: string;
  enableLogging: boolean;
  sessionId: string;
  ragOptions: {
    topK: number;
    indexName: string;
  };
  solverOptions: {
    time_limit: number;
    construction_heuristics: boolean;
  };
}

export class ConstructionWorkflowOrchestrator {
  private sessionId: string;
  private modelProvider: 'anthropic' | 'openai';
  private modelName: string;
  private agentIds: string[] = [];
  private enableLogging: boolean;
  private solverOptions: any;
  private solver: ConstructionMCPSolver;
  private ragOptions: any;

  constructor(options: WorkflowOptions) {
    this.sessionId = options.sessionId;
    this.modelProvider = options.modelProvider;
    this.modelName = options.modelName;
    this.enableLogging = options.enableLogging;
    this.solverOptions = options.solverOptions;
    this.solver = new ConstructionMCPSolver();
    this.ragOptions = options.ragOptions;
  }

  private log(message: string, data?: any) {
    if (this.enableLogging) {
      console.log(`[ConstructionWorkflow] ${message}`, data || '');
    }
  }

  /**
   * Execute RAG query against knowledge base
   */
  private async executeRAGQuery(query: string): Promise<{ answer: string; sources: any[] }> {
    this.log('Executing RAG query', { query });
    
    try {
      // Generate embedding for the query
      const [embedding] = await embedChunks([query]);
      
      // Query the vector database
      const results = await queryVectors(this.ragOptions.indexName, embedding, this.ragOptions.topK);
      
      // Build context from retrieved documents
      const context = results.map((r: any, i: number) =>
        `Source ${i + 1} (${r.metadata?.sourceType || 'unknown'}):\n${r.metadata?.chunk || ''}`
      ).join('\n---\n');

      // Generate answer using LLM
      let llmAnswer = '';
      try {
        llmAnswer = await getLLMAnswer(query, context);
      } catch (err) {
        llmAnswer = '[LLM answer synthesis failed]';
      }

      return {
        answer: llmAnswer,
        sources: results
      };
    } catch (error: any) {
      this.log('RAG query failed', { error: error.message });
      throw new Error(`RAG query failed: ${error.message}`);
    }
  }

  /**
   * Execute the complete construction workflow
   */
  async execute(
    customerData: any,
    userQuery: string
  ): Promise<ConstructionWorkflowResult> {
    const startTime = Date.now();
    this.log('Starting construction workflow', { userQuery, sessionId: this.sessionId });

    try {
      // Step 1: Intent Analysis
      this.log('Step 1: Analyzing intent...');
      const intent = await agnoIntentAgent.analyzeIntent(
        userQuery,
        this.sessionId,
        this.modelProvider,
        this.modelName
      );
      this.log('Intent analysis complete', intent);

      // Step 2: Determine execution path
      const executionPath = this.determineExecutionPath(intent);
      this.log('Execution path determined', { executionPath, decisionType: intent.decisionType });

      // Step 3: Execute based on path
      let result: ConstructionWorkflowResult;

      if (executionPath === 'rag') {
        result = await this.executeRAGPath(intent, userQuery);
      } else if (executionPath === 'optimization') {
        result = await this.executeOptimizationPath(intent, customerData);
      } else {
        result = await this.executeHybridPath(intent, customerData, userQuery);
      }

      // Add metadata
      result.metadata.duration = Date.now() - startTime;
      result.metadata.modelName = this.modelName;

      this.log('Workflow completed successfully', {
        executionPath: result.metadata.executionPath,
        duration: result.metadata.duration
      });

      return result;

    } catch (error: any) {
      this.log('Workflow failed', { error: error.message });
      throw error;
    }
  }

  /**
   * Determine the execution path based on intent analysis
   */
  private determineExecutionPath(intent: IntentResult): 'rag' | 'optimization' | 'hybrid' {
    if (intent.primaryIntent === 'knowledge_retrieval') {
      return 'rag';
    } else if (intent.primaryIntent === 'optimization') {
      return 'optimization';
    } else {
      return 'hybrid';
    }
  }

  /**
   * Execute RAG-only path for knowledge queries
   */
  private async executeRAGPath(intent: IntentResult, userQuery: string): Promise<ConstructionWorkflowResult> {
    this.log('Executing RAG path');

    if (!intent.ragQuery) {
      throw new Error('RAG query not found in intent analysis');
    }

    const request: AgnoChatRequest = {
      message: intent.ragQuery,
      session_id: this.sessionId,
      model_provider: this.modelProvider,
      model_name: this.modelName,
      context: {
        timestamp: new Date().toISOString(),
        inputType: 'knowledge_query',
        decisionType: intent.decisionType,
        agentType: 'construction_rag'
      }
    };

    const ragResult = await agnoClient.chat(request);
    
    const result: ConstructionWorkflowResult = {
      intent,
      explanation: {
        summary: 'Knowledge-based response provided',
        keyDecisions: ['Used RAG path for knowledge query'],
        recommendations: ['Continue with knowledge-based approach'],
        insights: ['Query identified as knowledge retrieval']
      },
      ragResult: {
        answer: typeof ragResult.response === 'string' ? ragResult.response : ragResult.response.answer || 'No answer provided',
        sources: typeof ragResult.response === 'string' ? [] : (ragResult.response.sources || [])
      },
      metadata: {
        executionPath: 'rag',
        duration: 0,
        modelName: this.modelName
      },
      sessionId: this.sessionId
    };

    return result;
  }

  /**
   * Execute optimization-only path for decision problems
   */
  private async executeOptimizationPath(intent: IntentResult, customerData: any): Promise<ConstructionWorkflowResult> {
    this.log('Executing optimization path');

    if (!customerData) {
      throw new Error('Customer data is required for optimization problems');
    }

    // Step 1: Enrich data
    const enrichedData = await agnoDataAgent.enrichData(
      customerData,
      this.sessionId,
      this.modelProvider,
      this.modelName
    );

    // Step 2: Build model
    const modelResult = await agnoModelBuilderAgent.buildModel(
      enrichedData.enrichedData,
      intent,
      this.sessionId,
      this.modelProvider,
      this.modelName
    );

    // Step 3: Solve optimization problem
    const solver = new ConstructionMCPSolver();
    const optimizationResult = await solver.solveConstructionOptimization(modelResult.mcpConfig, this.solverOptions);

    // Step 4: Get explanation
    const explanation = await this.getExplanation(intent, modelResult.mcpConfig, optimizationResult);

    const result: ConstructionWorkflowResult = {
      intent,
      enrichedData,
      mcpConfig: modelResult.mcpConfig,
      optimizationResult,
      optimizationProblem: modelResult.mcpConfig,
      explanation,
      metadata: {
        executionPath: 'optimization',
        duration: 0,
        modelName: this.modelName,
        solverUsed: solver.isHighsAvailable() ? 'HiGHS' : 'Fallback'
      },
      sessionId: this.sessionId
    };

    return result;
  }

  /**
   * Execute hybrid path for complex problems
   */
  private async executeHybridPath(intent: IntentResult, customerData: any, userQuery: string): Promise<ConstructionWorkflowResult> {
    this.log('Executing hybrid path');

    if (!customerData) {
      throw new Error('Customer data is required for hybrid analysis');
    }

    // Step 1: Get RAG results
    const ragRequest: AgnoChatRequest = {
      message: intent.ragQuery || userQuery,
      session_id: this.sessionId,
      model_provider: this.modelProvider,
      model_name: this.modelName,
      context: {
        timestamp: new Date().toISOString(),
        inputType: 'hybrid_analysis',
        decisionType: intent.decisionType,
        agentType: 'construction_hybrid'
      }
    };

    const ragResult = await agnoClient.chat(ragRequest);

    // Step 2: Enrich data
    const enrichedData = await agnoDataAgent.enrichData(
      customerData,
      this.sessionId,
      this.modelProvider,
      this.modelName
    );

    // Step 3: Build model
    const modelResult = await agnoModelBuilderAgent.buildModel(
      enrichedData.enrichedData,
      intent,
      this.sessionId,
      this.modelProvider,
      this.modelName
    );

    // Step 4: Solve optimization problem
    const solver = new ConstructionMCPSolver();
    const optimizationResult = await solver.solveConstructionOptimization(modelResult.mcpConfig, this.solverOptions);

    // Step 5: Get explanation
    const explanation = await this.getExplanation(intent, modelResult.mcpConfig, optimizationResult);

    const result: ConstructionWorkflowResult = {
      intent,
      enrichedData,
      mcpConfig: modelResult.mcpConfig,
      optimizationResult,
      optimizationProblem: modelResult.mcpConfig,
      explanation,
      ragResult: {
        answer: typeof ragResult.response === 'string' ? ragResult.response : ragResult.response.answer || 'No answer provided',
        sources: typeof ragResult.response === 'string' ? [] : (ragResult.response.sources || [])
      },
      metadata: {
        executionPath: 'hybrid',
        duration: 0,
        modelName: this.modelName,
        solverUsed: solver.isHighsAvailable() ? 'HiGHS' : 'Fallback'
      },
      sessionId: this.sessionId
    };

    return result;
  }

  /**
   * Get explanation for optimization results
   */
  private async getExplanation(intent: IntentResult, mcpConfig: MCPConfig, optimizationResult: any) {
    const prompt = `Explain the optimization results for the construction problem:

Intent: ${JSON.stringify(intent, null, 2)}
Model: ${JSON.stringify(mcpConfig, null, 2)}
Results: ${JSON.stringify(optimizationResult, null, 2)}

Please provide a structured explanation with:
1. Summary of the solution
2. Key decisions made
3. Recommendations for implementation
4. Insights and observations`;

    const request: AgnoChatRequest = {
      message: prompt,
      session_id: this.sessionId,
      model_provider: this.modelProvider,
      model_name: this.modelName,
      context: {
        timestamp: new Date().toISOString(),
        inputType: 'explanation',
        decisionType: intent.decisionType,
        agentType: 'construction_explainer'
      }
    };

    const response = await agnoClient.chat(request);
    const explanationText = typeof response.response === 'string' ? response.response : response.response.explanation || 'No explanation provided';

    return {
      summary: explanationText,
      keyDecisions: ['Optimization completed successfully'],
      recommendations: ['Implement the optimized solution'],
      insights: ['Solution provides optimal resource allocation']
    };
  }

  /**
   * Execute a specific step of the workflow
   * @param step The step to execute
   * @param data Required data for the step
   * @returns Step result
   */
  async executeStep(
    step: 'data_enrichment' | 'intent_interpretation' | 'model_building' | 'optimization' | 'explanation',
    data: any
  ) {
    this.log(`Executing step: ${step}`);

    switch (step) {
      case 'data_enrichment':
        return await agnoDataAgent.enrichData(
          data.customerData,
          this.sessionId,
          this.modelProvider,
          this.modelName
        );

      case 'intent_interpretation':
        return await agnoIntentAgent.interpretIntent(
          data.userIntent,
          this.sessionId,
          this.modelProvider,
          this.modelName
        );

      case 'model_building':
        return await agnoModelBuilderAgent.buildModel(
          data.enrichedData,
          data.intent,
          this.sessionId,
          this.modelProvider,
          this.modelName
        );

      case 'optimization':
        const optimizationProblem = this.convertMCPConfigToConstructionProblem(
          data.mcpConfig,
          data.enrichedData,
          data.intent
        );
        return await this.solver.solveConstructionOptimization(
          optimizationProblem,
          this.solverOptions,
          { sessionId: this.sessionId }
        );

      case 'explanation':
        return await agnoExplainAgent.explainSolution(
          data.solution,
          this.sessionId,
          this.modelProvider,
          this.modelName
        );

      default:
        throw new Error(`Unknown step: ${step}`);
    }
  }

  /**
   * Get workflow status and metadata
   * @returns Workflow status
   */
  getStatus() {
    return {
      sessionId: this.sessionId,
      modelProvider: this.modelProvider,
      modelName: this.modelName,
      agentIds: this.agentIds,
      enableLogging: this.enableLogging,
      solverOptions: this.solverOptions,
      highsAvailable: this.solver.isHighsAvailable()
    };
  }

  /**
   * Clean up resources
   */
  async cleanup() {
    this.log('Cleaning up workflow resources');
    // Clean up specialized agents if they were created
    for (const agentId of this.agentIds) {
      try {
        await agnoClient.deleteAgent(agentId);
      } catch (error: any) {
        this.log('Failed to delete agent', { agentId, error: error.message });
      }
    }
    this.agentIds = [];
  }
}

// Convenience function for quick workflow execution
export async function executeConstructionWorkflow(
  customerData: any,
  userInput: string,
  options: WorkflowOptions = {}
): Promise<ConstructionWorkflowResult> {
  const {
    modelProvider = 'anthropic',
    modelName,
    enableLogging = true,
    sessionId = `construction_${Date.now()}`,
    ragOptions = { topK: 5, indexName: 'dcisionai-construction-kb' },
    solverOptions = { time_limit: 300, construction_heuristics: true }
  } = options;

  try {
    // Step 1: Intent Analysis
    const intent = await agnoIntentAgent.interpretIntent(
      userInput,
      sessionId,
      modelProvider,
      modelName
    );

    if (enableLogging) {
      console.log('Intent Analysis:', intent);
    }

    // Step 2: Execute based on intent path
    let result: any = {
      intent,
      metadata: {
        executionPath: intent.executionPath,
        modelName: modelName || (modelProvider === 'anthropic' ? 'claude-3-sonnet-20240229' : 'gpt-4-turbo-preview'),
        duration: 0,
        solverUsed: null
      },
      sessionId
    };

    const startTime = Date.now();

    if (intent.executionPath === 'rag') {
      // RAG-only path
      const ragResult = await agnoClient.chat({
        message: intent.ragQuery,
        session_id: sessionId,
        model_provider: modelProvider,
        model_name: modelName,
        context: {
          query_type: 'construction_knowledge',
          domain: 'construction',
          index_name: ragOptions.indexName
        }
      });

      result.ragResult = {
        answer: typeof ragResult.response === 'string' ? ragResult.response : ragResult.response.answer,
        sources: typeof ragResult.response === 'string' ? [] : (ragResult.response.sources || [])
      };

    } else if (intent.executionPath === 'optimization') {
      // Optimization path
      if (!customerData) {
        throw new Error('Customer data is required for optimization queries');
      }

      // Step 2a: Data Enrichment
      const enrichedData = await agnoDataAgent.enrichData(
        customerData,
        intent,
        sessionId,
        modelProvider,
        modelName
      );

      // Step 2b: Model Building
      const { mcpConfig } = await agnoModelBuilderAgent.buildModel(
        enrichedData,
        intent,
        sessionId,
        modelProvider,
        modelName
      );

      // Step 2c: Solve Optimization Problem
      const solver = new ConstructionMCPSolver(solverOptions);
      
      // Convert MCP config to construction optimization problem format
      const constructionProblem = {
        problem_type: 'resource_allocation' as const,
        sense: 'minimize' as const,
        objective: {
          linear: mcpConfig.objective.coefficients || [1, 1, 1, 1]
        },
        variables: mcpConfig.variables.map(v => ({
          name: v.name,
          type: v.type as 'cont' | 'int' | 'bin',
          lb: v.lower_bound,
          ub: v.upper_bound,
          description: v.description,
          category: 'worker' as const
        })),
        constraints: {
          dense: mcpConfig.constraints.dense || [[1, 1, 1, 1]],
          sense: ['<=' as const],
          rhs: [100],
          categories: ['capacity' as const]
        }
      };
      
      const optimizationResult = await solver.solveConstructionOptimization(constructionProblem, solverOptions);

      // Step 2d: Generate Explanation
      const explanation = await agnoExplainAgent.explainSolution(
        {
          ...optimizationResult,
          status: 'optimization_completed'
        },
        sessionId,
        modelProvider,
        modelName
      );

      result.optimizationResult = optimizationResult;
      result.optimizationProblem = mcpConfig;
      result.explanation = explanation;
      result.metadata.solverUsed = solver.isHighsAvailable() ? 'HiGHS' : 'Fallback';

    } else if (intent.executionPath === 'hybrid') {
      // Hybrid path (RAG + Optimization)
      // First get knowledge context
      const ragResult = await agnoClient.chat({
        message: intent.ragQuery,
        session_id: sessionId,
        model_provider: modelProvider,
        model_name: modelName,
        context: {
          query_type: 'construction_knowledge',
          domain: 'construction',
          index_name: ragOptions.indexName
        }
      });

      result.ragResult = {
        answer: typeof ragResult.response === 'string' ? ragResult.response : ragResult.response.answer,
        sources: typeof ragResult.response === 'string' ? [] : (ragResult.response.sources || [])
      };

      if (customerData) {
        // Then do optimization if we have customer data
        const enrichedData = await agnoDataAgent.enrichData(
          customerData,
          intent,
          sessionId,
          modelProvider,
          modelName
        );

        const { mcpConfig } = await agnoModelBuilderAgent.buildModel(
          enrichedData,
          intent,
          sessionId,
          modelProvider,
          modelName
        );

        const solver = new ConstructionMCPSolver(solverOptions);
        
        // Convert MCP config to construction optimization problem format
        const constructionProblem = {
          problem_type: 'resource_allocation' as const,
          sense: 'minimize' as const,
          objective: {
            linear: mcpConfig.objective.coefficients || [1, 1, 1, 1]
          },
          variables: mcpConfig.variables.map((v: any) => ({
            name: v.name,
            type: v.type as 'cont' | 'int' | 'bin',
            lb: v.lower_bound,
            ub: v.upper_bound,
            description: v.description,
            category: 'worker' as const
          })),
          constraints: {
            dense: mcpConfig.constraints.dense || [[1, 1, 1, 1]],
            sense: ['<=' as const],
            rhs: [100],
            categories: ['capacity' as const]
          }
        };
        
        const optimizationResult = await solver.solveConstructionOptimization(constructionProblem, solverOptions);

        const explanation = await agnoExplainAgent.explainSolution(
          {
            ...optimizationResult,
            status: 'optimization_completed'
          },
          sessionId,
          modelProvider,
          modelName
        );

        result.optimizationResult = optimizationResult;
        result.optimizationProblem = mcpConfig;
        result.explanation = explanation;
        result.metadata.solverUsed = solver.isHighsAvailable() ? 'HiGHS' : 'Fallback';
      }
    }

    result.metadata.duration = Date.now() - startTime;

    return result;

  } catch (error: any) {
    console.error('Construction workflow error:', error);
    throw new Error(`Construction workflow failed: ${error.message}`);
  }
} 